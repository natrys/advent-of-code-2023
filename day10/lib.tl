(defstruct (point x y) ()
  x y
  (:method lambda (self) (mref grid self.y self.x))
  (:method lambda-set (self type) (set [[grid self.y] self.x] type))
  (:method above (self) (new (point self.x (- self.y 1))))
  (:method below (self) (new (point self.x (+ self.y 1))))
  (:method left (self) (new (point (- self.x 1) self.y)))
  (:method right (self) (new (point (+ self.x 1) self.y)))
  (:method top-left (self) (new (point (- self.x 1) (- self.y 1))))
  (:method bottom-right (self) (new (point (+ self.x 1) (+ self.y 1))))
  (:method neighbors (self) (list self.(above) self.(right) self.(below) self.(left))))

(defun find-start ()
  (dotimes (y ylim)
    (dotimes (x xlim)
      (when (= (mref grid y x) #\S)
        (return-from find-start
          (new (point x y)))))))

(defun deduce-type (point)
  (let ((surrounding (mapcar (op @1) point.(neighbors)))
        (types (list #\L #\J #\7 #\F #\| #\-)))
    (each ((type types))
      (match-case (cons type surrounding)
        ((#\L . (@(or #\| #\F #\7) @(or #\- #\J #\7) @nil @nil)) (return-from deduce-type type))
        ((#\J . (@(or #\| #\F #\7) @nil @nil @(or #\- #\F #\L))) (return-from deduce-type type))
        ((#\| . (@(or #\| #\F #\7) @nil @(or #\| #\L #\J) @nil)) (return-from deduce-type type))
        ((#\7 . (@nil @nil @(or #\| #\L #\J) @(or #\- #\F #\L))) (return-from deduce-type type))
        ((#\F . (@nil @(or #\- #\J #\7) @(or #\| #\L #\J) @nil)) (return-from deduce-type type))
        ((#\- . (@nil @(or #\- #\J #\7) @nil @(or #\- #\F #\L))) (return-from deduce-type type))))))

(defun next-hop (pos)
  (match-case [pos]
    (#\L (list pos.(above) pos.(right)))
    (#\J (list pos.(above) pos.(left)))
    (#\| (list pos.(above) pos.(below)))
    (#\7 (list pos.(left) pos.(below)))
    (#\F (list pos.(right) pos.(below)))
    (#\- (list pos.(left) pos.(right)))))

(defun edge-direction (pos)
  (match-case (car (grade (list pos.y (- ylim pos.y)) '<))
    (0 (cons pos.top-left (op and (> @1.x 0) (> @1.y 0))))
    (1 (cons pos.bottom-right (op and (< @1.x xlim) (< @1.y ylim))))))

(defun ray-hits (start)
  (when-match (@next . @check) (edge-direction start)
    (doloop ((pos start [next pos])
             (hits 0 (if (and (inhash loop pos) 
                            (not (or (= [pos] #\L) 
                                     (= [pos] #\7))))
                     (+ hits 1) hits)))
    ([check pos] hits))))

(defun part1 ()
  (let ((start (find-start)))
    (set [start] (deduce-type start))
    (doloop ((queue (list start) (remove-if (op inhash loop @1) (mappend* 'next-hop queue)))
             (distance -1 (+ 1 distance)))
      ((nullify queue) distance)
      (each ((next queue)) (sethash loop next nil)))))

(defun part2 ()
  (let ((counter 0) (pos))
    (each ((y 1..(- ylim 1)))
      (each ((x 1..(- xlim 1)))
        (set pos (new (point x y)))
        (unless (inhash loop pos)
          (when (oddp (ray-hits pos))
            (inc counter)))))
    counter))

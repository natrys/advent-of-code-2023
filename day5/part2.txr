@(do
   (defstruct (mapping dest source range) ()
     dest source range
     (:method translate (self elem)
       (when (and (>= elem self.source) (< elem (+ self.source self.range)))
         (cons (+ self.dest (- elem self.source)) (- (+ self.source self.range) elem))))))
@(define read-map (maps))
@ (collect :maxgap 1 :vars (maps))
@dest @source @range
@  (bind maps @(new (mapping (num-str dest) (num-str source) (num-str range))))
@ (end)
@(end)
seeds: @(coll)@{seeds /\d+/}@(end)

@(read-map soil)
@(read-map fertilizer)
@(read-map water)
@(read-map light)
@(read-map temperature)
@(read-map humidity)
@(read-map location)
@(bind layers @(mapcar (op sort @1 '< (lambda (m) m.source))
                       (list soil fertilizer water light temperature humidity location)))
@(do
   (let* ((seeds (mapcar 'num-str seeds))
          (seed-ranges (mapcar (op apply (op rcons @1 (+ @1 @2))) (tuples 2 seeds)))
          (part2 (let ((m (car (sort [layers -1] '> (lambda (m) m.dest))))) (+ m.dest m.range))))
     (each ((range seed-ranges))
       (let ((seed (from range)) (end (to range)) (skip) (hop))
         (while (< seed end)
           (set hop seed skip (- end seed))
           (each ((layer layers))
             (doloop ((i 0 (inc i))) ([< i (len layer)])
               (whenlet ((r [layer i].(translate hop)))
                 (set hop (car r))
                 (set skip (min skip (cdr r)))
                 (return))))
           (inc seed skip)
           (set part2 (min part2 hop)))))
     (put-line `Part2: @part2`)))
